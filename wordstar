// Define wordstar cursor control keys
// e.g. Ctrl-Q followed by S or D for left/right; E or X for up/down

partial modifier_keys alphanumeric_keys
xkb_symbols "keys" {
  include "wordstar(caps_key)"
  include "wordstar(qkeys)"
};

// Wordstar keys with caps-q prefix
// Note: key <AD02> is the W key: D means row D (spacebar row is row A) and key number 01 = 1 key from the left (i.e. from tab)
partial modifier_keys alphanumeric_keys
xkb_symbols "qkeys" {
  include "wordstar(level5_enable)"  // includes clode below

  // Note, the following Q key prefix can be implemented with ISO_Group_Latch instead of ISO_Level5_Latch
  // and then changing all the the definition tables below to have a second set of square brackets that covers prefix keyed actions
  // e.g. { [NoSymbol, NoSymbol, Left], [End] };
  // This would work, but if there are two layouts loaded (e.g. English and Greek) 
  // then we'd clobber Greek which would be loaded as group 2
  key.type[Group1] = "EIGHT_LEVEL_ALPHABETIC";
  key <AD01> { [ NoSymbol, NoSymbol, ISO_Level5_Latch, ISO_Level5_Latch ] }; // Q
  key <AD02> { [ NoSymbol, NoSymbol, Pointer_Button4 ] }; // W
  key <AD03> { [ NoSymbol, NoSymbol, Up, Up, Up, Up, Up, Up ], [Up, Up] };  // E
  key <AD04> { [ NoSymbol, NoSymbol, Prior, Prior ], [Prior, Prior] }; // R
  key <AC01> { [ NoSymbol, NoSymbol, Left, Left ], [Left, Left] };  // A
  key <AC02> { [ NoSymbol, NoSymbol, Left, Left, NoSymbol, NoSymbol, Home ] , [Left, Left] }; // S
  key <AC03> { [ NoSymbol, NoSymbol, Right, Right, Up, Up, End ], [0xfd15, 0xfd15] };  // D
  key <AC04> { [ NoSymbol, NoSymbol, Right, Right, NoSymbol, NoSymbol, Find ], [Right, Right]  };  // F
  key <AC05> { [ NoSymbol, NoSymbol, Delete, Delete ] };  // G
  key <AC06> { [ NoSymbol, NoSymbol, BackSpace, BackSpace ], [ Shift_L, Shift_L ] };  // H
  key <AC08> { [ NoSymbol, NoSymbol, ISO_Group_Latch, ISO_Group_Latch ], [ Shift_Lock, Shift_Lock ] }; // K
  key <AC09> { [ NoSymbol, NoSymbol, F3, F3 ] };       // L - repeat find
  key <AB01> { [ NoSymbol, NoSymbol, Pointer_Button5 ] }; // Z
  key <AB02> { [ NoSymbol, NoSymbol, Down, Down ], [Down, Down] };  // X
  key <AB03> { [ NoSymbol, NoSymbol, Next, Next ], [Next, Next] };  // C
  key <AB06> { [ NoSymbol, NoSymbol, Return ] };  // N
};

// Assign an actual keysym to ISO_Level5_Shift
// Otherwise Ctrl-Q key prefixes don't work. Don't know why.
// For some reason this is necessary to make ISO_Level5_Latch also work (i.e. our Ctrl-Q prefix)
// This code is stolen from 'include "level5(modifier_mapping)"', but using that defines the <MDSW> key instead
// and then the compiler complains that "<MDSW> is added to map for multiple modifiers"
// and it ignores one of the definitions, making this flakey.
// I've chosen key <I153> because it's unlikely to be used (defined as KEY_SENDFILE in evdev)
// If you want a real key, say <RCTL> as a level 5 shift, specify it instead.
// see /usr/share/X11/xkb/keycodes/evdev for key definitions like <I153>
partial modifier_keys
xkb_symbols "level5_enable" {
  replace key <I153> {
    type[Group1] = "ONE_LEVEL",
    symbols[Group1] = [ ISO_Level5_Shift ]
  };
  modifier_map Mod3 { <I153> };
};

// Make capslock generate the level3 modifier
partial modifier_keys
xkb_symbols "caps_key" {
  key <CAPS> {
    type[Group1]="ONE_LEVEL",
    symbols[Group1] = [ ISO_Level3_Shift ]
  };
  include "level3(modifier_mapping)"
};

default partial xkb_compatibility "mousekeys" {
  // Keypad actions.
  interpret.repeat= True;
  interpret WheelUp {
      action = PointerButton(button=4);
  };
  interpret WheelDown {
      action = PointerButton(button=5);
  };
  key <AD02> { [ NoSymbol, NoSymbol, WheelUp, WheelUp ] };
  key <AB01> { [ NoSymbol, NoSymbol, WheelDown, WheelDown ] };
};
